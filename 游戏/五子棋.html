<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹ (AIä¸åŒäººæ¨¡å¼)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* è‡ªå®šä¹‰æ£‹ç›˜å’Œæ£‹å­æ ·å¼ */
        .board-cell {
            width: 30px; /* å•å…ƒæ ¼å®½åº¦ */
            height: 30px; /* å•å…ƒæ ¼é«˜åº¦ */
            background-color: #f0c27b; /* æ£‹ç›˜å•å…ƒæ ¼èƒŒæ™¯è‰² (æœ¨è‰²) */
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #d3a05a; /* å•å…ƒæ ¼è¾¹æ¡†ï¼Œå½¢æˆæ ¼å­çº¿ */
            box-sizing: border-box;
            cursor: pointer;
        }
        .board-cell:hover {
            background-color: #e6b86f; /* é¼ æ ‡æ‚¬åœæ—¶é¢œè‰²å˜æµ… */
        }
        .board-container {
            display: grid;
            grid-template-columns: repeat(15, 30px); /* 15åˆ—ï¼Œæ¯åˆ—30px */
            grid-template-rows: repeat(15, 30px);    /* 15è¡Œï¼Œæ¯è¡Œ30px */
            border: 2px solid #8b5a2b; /* æ£‹ç›˜å¤–è¾¹æ¡† */
            background-color: #d3a05a; /* æ ¼å­çº¿é¢œè‰²ï¼Œé€šè¿‡å•å…ƒæ ¼è¾¹æ¡†å®ç° */
            width: calc(15 * 30px); /* æ€»å®½åº¦ */
            height: calc(15 * 30px); /* æ€»é«˜åº¦ */
        }
        .piece {
            width: 24px;  /* æ£‹å­å¤§å° */
            height: 24px; /* æ£‹å­å¤§å° */
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .piece.player-one { /* é»‘æ£‹æ ·å¼ */
            background-color: black;
        }
        .piece.player-two { /* ç™½æ£‹æ ·å¼ */
            background-color: white;
            border: 1px solid #ccc; /* AIç™½è‰²æ£‹å­è¾¹æ¡†ï¼Œä½¿å…¶åœ¨æ£‹ç›˜ä¸Šæ›´æ˜æ˜¾ */
        }
        /* éšè— Tailwind é»˜è®¤çš„ ring æ•ˆæœï¼Œé¿å…ä¸æ£‹ç›˜äº¤äº’å†²çª */
        button:focus, input:focus {
            outline: none !important;
            box-shadow: none !important;
        }
        /* æ¸¸æˆç»“æŸæ—¶æ£‹ç›˜é®ç½© */
        .board-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(128, 128, 128, 0.3); /* åŠé€æ˜ç°è‰² */
            z-index: 5; /* ç¡®ä¿åœ¨æ£‹å­ä¹‹ä¸Šï¼Œä½†åœ¨æ¶ˆæ¯æ¡†ä¹‹ä¸‹ */
            display: none; /* é»˜è®¤éšè— */
            cursor: not-allowed;
        }
        .board-container-wrapper {
            position: relative; /* ç”¨äºå®šä½é®ç½©å±‚ */
        }
        .controls button.active-mode { /* ç”¨äºé«˜äº®å½“å‰æ¨¡å¼çš„æŒ‰é’® */
            /* Tailwind ring classes will be applied via JS */
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4 font-sans">

    <div class="container mx-auto p-4 flex flex-col items-center bg-white shadow-xl rounded-lg w-full max-w-md sm:max-w-lg md:max-w-xl">
        <h1 class="text-2xl sm:text-3xl font-bold mb-6 text-gray-800 text-center">äº”å­æ£‹å¯¹æˆ˜</h1>

        <div class="controls mb-6 flex flex-col sm:flex-row flex-wrap space-y-2 sm:space-y-0 sm:space-x-2 items-center justify-center w-full">
            <button id="mode-two-player" class="w-full sm:w-auto bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">åŒäººå¯¹æˆ˜</button>
            <button id="difficulty-medium" class="w-full sm:w-auto bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">AI ä¸­ç­‰</button>
            <button id="difficulty-hard" class="w-full sm:w-auto bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">AI å›°éš¾</button>
            <button id="restart-button" class="w-full sm:w-auto bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out mt-2 sm:mt-0 sm:ml-4">é‡æ–°å¼€å§‹</button>
        </div>

        <div id="game-status" class="mb-4 text-lg sm:text-xl font-semibold text-gray-700 h-8 text-center">è¯·é€‰æ‹©æ¸¸æˆæ¨¡å¼å¼€å§‹æ¸¸æˆ</div>

        <div class="board-container-wrapper">
            <div id="board-container" class="board-container shadow-lg rounded overflow-hidden">
                </div>
            <div id="board-overlay" class="board-overlay"></div>
        </div>

        <div id="message-box" class="fixed inset-0 bg-gray-900 bg-opacity-60 flex items-center justify-center hidden z-50 p-4">
            <div class="bg-white p-6 sm:p-8 rounded-lg shadow-2xl text-center max-w-xs sm:max-w-sm w-full">
                <p id="message-text" class="text-lg sm:text-xl mb-6 text-gray-800"></p>
                <button id="message-ok-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-6 rounded-md transition duration-150 ease-in-out">å¥½çš„</button>
            </div>
        </div>
    </div>

    <footer class="mt-8 text-center text-gray-600 text-sm">
        <p>Copyright Â©AIå·¥å…·æ ˆå¤§å”</p>
    </footer>

    <script>
        // --- æ¸¸æˆå¸¸é‡ ---
        const BOARD_SIZE = 15;      // æ£‹ç›˜å¤§å° (15x15)
        const EMPTY = 0;            // ç©ºä½
        const PLAYER_ONE_PIECE = 1; // ç©å®¶1 / é»‘æ£‹
        const PLAYER_TWO_PIECE = 2; // ç©å®¶2 / AI / ç™½æ£‹
        const WIN_SCORE = 1000000;  // èƒœåˆ©åˆ†æ•° (ç”¨äºAIè¯„ä¼°)

        // --- æ¸¸æˆçŠ¶æ€å˜é‡ ---
        let board = [];             // æ£‹ç›˜çŠ¶æ€ (äºŒç»´æ•°ç»„)
        let currentPlayer = PLAYER_ONE_PIECE; // å½“å‰æ‰§å­æ–¹
        let gameOver = true;        // æ¸¸æˆæ˜¯å¦ç»“æŸ
        let gameMode = null;        // æ¸¸æˆæ¨¡å¼: null, 'ai', 'twoPlayer'
        let currentDifficulty = null; // AIéš¾åº¦: 'medium' æˆ– 'hard'
        let moveHistory = [];

        // --- DOMå…ƒç´ è·å– ---
        const boardContainer = document.getElementById('board-container');
        const gameStatusDiv = document.getElementById('game-status');
        const modeTwoPlayerButton = document.getElementById('mode-two-player');
        const difficultyMediumButton = document.getElementById('difficulty-medium');
        const difficultyHardButton = document.getElementById('difficulty-hard');
        const restartButton = document.getElementById('restart-button');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageOkButton = document.getElementById('message-ok-button');
        const boardOverlay = document.getElementById('board-overlay');

        // --- äº‹ä»¶å¤„ç†å‡½æ•° ---
        modeTwoPlayerButton.addEventListener('click', () => setGameModeAndStart('twoPlayer'));
        difficultyMediumButton.addEventListener('click', () => setGameModeAndStart('ai', 'medium'));
        difficultyHardButton.addEventListener('click', () => setGameModeAndStart('ai', 'hard'));

        restartButton.addEventListener('click', () => {
            if (gameMode) { // åªæœ‰åœ¨é€‰æ‹©äº†æ¨¡å¼åæ‰èƒ½é‡æ–°å¼€å§‹
                initGame();
            } else {
                showMessage("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ¸¸æˆæ¨¡å¼ã€‚");
            }
        });
        messageOkButton.addEventListener('click', hideMessage);


        /**
         * è®¾ç½®æ¸¸æˆæ¨¡å¼å’Œéš¾åº¦ï¼Œç„¶åå¼€å§‹æ–°æ¸¸æˆã€‚
         * @param {string} mode - 'ai' æˆ– 'twoPlayer'
         * @param {string|null} [difficulty=null] - 'medium' æˆ– 'hard', ä»…å½“æ¨¡å¼ä¸º 'ai' æ—¶æœ‰æ•ˆ
         */
        function setGameModeAndStart(mode, difficulty = null) {
            gameMode = mode;
            currentDifficulty = (mode === 'ai') ? difficulty : null;

            // æ›´æ–°æŒ‰é’®æ ·å¼ä»¥æ˜¾ç¤ºæ´»åŠ¨æ¨¡å¼/éš¾åº¦
            modeTwoPlayerButton.classList.remove('ring-4', 'ring-purple-300', 'active-mode');
            difficultyMediumButton.classList.remove('ring-4', 'ring-blue-300', 'active-mode');
            difficultyHardButton.classList.remove('ring-4', 'ring-red-300', 'active-mode');

            if (mode === 'twoPlayer') {
                modeTwoPlayerButton.classList.add('ring-4', 'ring-purple-300', 'active-mode');
            } else if (mode === 'ai') {
                if (difficulty === 'medium') {
                    difficultyMediumButton.classList.add('ring-4', 'ring-blue-300', 'active-mode');
                } else if (difficulty === 'hard') {
                    difficultyHardButton.classList.add('ring-4', 'ring-red-300', 'active-mode');
                }
            }
            initGame();
        }


        /**
         * åˆå§‹åŒ–æ£‹ç›˜æ•°ç»„å’Œæ¸¸æˆçŠ¶æ€
         */
        function initGame() {
            board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY));
            currentPlayer = PLAYER_ONE_PIECE; // é»‘æ£‹ (ç©å®¶1) æ€»æ˜¯å…ˆæ‰‹
            gameOver = false;
            moveHistory = [];
            drawBoard(); // é‡ç»˜æ£‹ç›˜

            if (!gameMode) {
                gameStatusDiv.textContent = 'è¯·é€‰æ‹©æ¸¸æˆæ¨¡å¼å¼€å§‹æ¸¸æˆ';
                gameOver = true; // å¦‚æœæ²¡æœ‰é€‰æ‹©æ¨¡å¼ï¼Œæ¸¸æˆä¸èƒ½å¼€å§‹
                boardOverlay.style.display = 'block'; // è¦†ç›–æ£‹ç›˜
                return;
            }
            boardOverlay.style.display = 'none'; // éšè—é®ç½©
            updateGameStatus(); // æ ¹æ®æ¨¡å¼è®¾ç½®åˆå§‹å›åˆæ¶ˆæ¯
        }

        /**
         * ç»˜åˆ¶æ£‹ç›˜å•å…ƒæ ¼
         */
        function drawBoard() {
            boardContainer.innerHTML = ''; // æ¸…ç©ºæ£‹ç›˜
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('board-cell');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.addEventListener('click', () => handleCellClick(r, c));

                    if (board[r][c] !== EMPTY) {
                        const piece = document.createElement('div');
                        piece.classList.add('piece');
                        // PLAYER_ONE_PIECE (é»‘æ£‹) ä½¿ç”¨ 'player-one' ç±»
                        // PLAYER_TWO_PIECE (ç™½æ£‹) ä½¿ç”¨ 'player-two' ç±»
                        piece.classList.add(board[r][c] === PLAYER_ONE_PIECE ? 'player-one' : 'player-two');
                        cell.appendChild(piece);
                    }
                    boardContainer.appendChild(cell);
                }
            }
        }


        /**
         * å¤„ç†å•å…ƒæ ¼ç‚¹å‡»äº‹ä»¶ (ç©å®¶è½å­)
         * @param {number} r - è¡Œç´¢å¼•
         * @param {number} c - åˆ—ç´¢å¼•
         */
        function handleCellClick(r, c) {
            if (gameOver || board[r][c] !== EMPTY || !gameMode) {
                return;
            }

            const pieceToPlace = currentPlayer;

            if (gameMode === 'ai') {
                if (currentPlayer !== PLAYER_ONE_PIECE) return; // AIæ¨¡å¼ä¸‹ï¼Œåªæœ‰ç©å®¶1 (é»‘æ£‹) èƒ½ç‚¹å‡»
                placePiece(r, c, PLAYER_ONE_PIECE);

                if (checkWin(r, c, PLAYER_ONE_PIECE)) {
                    gameOver = true;
                    updateGameStatus('ä½ èµ¢äº†ï¼ğŸ‰');
                    showMessage('æ­å–œä½ ï¼Œä½ èµ¢äº†ï¼');
                    boardOverlay.style.display = 'block';
                    return;
                }
            } else if (gameMode === 'twoPlayer') {
                placePiece(r, c, pieceToPlace);

                if (checkWin(r, c, pieceToPlace)) {
                    gameOver = true;
                    const winnerName = pieceToPlace === PLAYER_ONE_PIECE ? "ç©å®¶1 (é»‘æ£‹)" : "ç©å®¶2 (ç™½æ£‹)";
                    updateGameStatus(`${winnerName} èµ¢äº†ï¼ğŸ‰`);
                    showMessage(`æ­å–œï¼Œ${winnerName} èµ¢äº†ï¼`);
                    boardOverlay.style.display = 'block';
                    return;
                }
            }

            if (checkDraw()) {
                gameOver = true;
                updateGameStatus('å¹³å±€ï¼');
                showMessage('æ£‹ç›˜å·²æ»¡ï¼Œå¹³å±€ï¼');
                boardOverlay.style.display = 'block';
                return;
            }

            // åˆ‡æ¢ç©å®¶æˆ–è§¦å‘AI
            if (gameMode === 'ai') {
                currentPlayer = PLAYER_TWO_PIECE; // AIçš„å›åˆ (ç™½æ£‹)
                updateGameStatus();
                setTimeout(aiMove, 500); // AIå»¶è¿Ÿè½å­
            } else if (gameMode === 'twoPlayer') {
                currentPlayer = (currentPlayer === PLAYER_ONE_PIECE) ? PLAYER_TWO_PIECE : PLAYER_ONE_PIECE;
                updateGameStatus();
            }
        }

        /**
         * åœ¨æ£‹ç›˜ä¸Šæ”¾ç½®æ£‹å­å¹¶æ›´æ–°æ˜¾ç¤º
         * @param {number} r - è¡Œç´¢å¼•
         * @param {number} c - åˆ—ç´¢å¼•
         * @param {number} player - PLAYER_ONE_PIECE æˆ– PLAYER_TWO_PIECE
         */
        function placePiece(r, c, player) {
            board[r][c] = player;
            moveHistory.push({r, c, player});
            const cell = boardContainer.querySelector(`[data-r='${r}'][data-c='${c}']`);
            if (cell) {
                const existingPiece = cell.querySelector('.piece');
                if (existingPiece) existingPiece.remove(); // ä¸€èˆ¬ä¸åº”å‘ç”Ÿ

                const piece = document.createElement('div');
                piece.classList.add('piece');
                piece.classList.add(player === PLAYER_ONE_PIECE ? 'player-one' : 'player-two');
                cell.appendChild(piece);
            }
        }

        /**
         * æ£€æŸ¥ä»æœ€åè½å­ç‚¹ (r, c) å¼€å§‹ï¼ŒæŒ‡å®šç©å®¶æ˜¯å¦è·èƒœ
         * @param {number} r - æœ€åè½å­çš„è¡Œ
         * @param {number} c - æœ€åè½å­çš„åˆ—
         * @param {number} player - è¦æ£€æŸ¥çš„ç©å®¶
         * @returns {boolean} - å¦‚æœè·èƒœåˆ™è¿”å› trueï¼Œå¦åˆ™ false
         */
        function checkWin(r, c, player) {
            const directions = [
                [0, 1],  // æ°´å¹³æ–¹å‘
                [1, 0],  // å‚ç›´æ–¹å‘
                [1, 1],  // å³ä¸‹æ–œæ–¹å‘ (\)
                [1, -1]  // å³ä¸Šæ–œæ–¹å‘ (/)
            ];

            for (const [dr, dc] of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) { // æ£€æŸ¥ä¸€ä¸ªæ–¹å‘
                    if (isValid(r + dr * i, c + dc * i) && board[r + dr * i][c + dc * i] === player) count++; else break;
                }
                for (let i = 1; i < 5; i++) { // æ£€æŸ¥ç›¸åæ–¹å‘
                    if (isValid(r - dr * i, c - dc * i) && board[r - dr * i][c - dc * i] === player) count++; else break;
                }
                if (count >= 5) return true;
            }
            return false;
        }

        /**
         * æ£€æŸ¥æ˜¯å¦å¹³å±€ (æ£‹ç›˜å·²æ»¡ä¸”æ— èƒœè€…)
         * @returns {boolean} - å¦‚æœå¹³å±€åˆ™è¿”å› true
         */
        function checkDraw() {
            return board.every(row => row.every(cell => cell !== EMPTY));
        }

        /**
         * æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨æ£‹ç›˜å†…
         * @param {number} r - è¡Œ
         * @param {number} c - åˆ—
         * @returns {boolean}
         */
        function isValid(r, c) {
            return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
        }

        // --- AI é€»è¾‘ ---
        /**
         * AI æ‰§è¡Œè½å­
         */
        function aiMove() {
            // AIæ€»æ˜¯æ‰§ PLAYER_TWO_PIECE (ç™½æ£‹)
            if (gameOver || gameMode !== 'ai' || currentPlayer !== PLAYER_TWO_PIECE) return;

            let bestMove;
            if (currentDifficulty === 'medium') {
                bestMove = findBestMoveMedium();
            } else if (currentDifficulty === 'hard') {
                bestMove = findBestMoveHard();
            } else {
                bestMove = findRandomMove(); // å¤‡ç”¨
            }
            
            if (!bestMove) {
                const availableMoves = getAllEmptyCells();
                if (availableMoves.length > 0) {
                    bestMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                } else { // æ²¡æœ‰å¯è½å­çš„åœ°æ–¹ (ç†è®ºä¸Š draw ä¼šå…ˆæ•è·)
                     if (!checkDraw()) {
                         gameOver = true; updateGameStatus('å¹³å±€ï¼'); showMessage('æ£‹ç›˜å·²æ»¡ï¼Œå¹³å±€ï¼'); boardOverlay.style.display = 'block';
                     }
                    return;
                }
            }

            placePiece(bestMove.r, bestMove.c, PLAYER_TWO_PIECE);

            if (checkWin(bestMove.r, bestMove.c, PLAYER_TWO_PIECE)) {
                gameOver = true;
                updateGameStatus('ç”µè„‘èµ¢äº†ï¼');
                showMessage('å¾ˆé—æ†¾ï¼Œç”µè„‘èµ¢äº†ï¼');
                boardOverlay.style.display = 'block';
                return;
            }

            if (checkDraw()) {
                gameOver = true; updateGameStatus('å¹³å±€ï¼'); showMessage('æ£‹ç›˜å·²æ»¡ï¼Œå¹³å±€ï¼'); boardOverlay.style.display = 'block';
                return;
            }

            currentPlayer = PLAYER_ONE_PIECE; // è½®åˆ°ç©å®¶1 (é»‘æ£‹)
            updateGameStatus();
        }
        
        /**
         * è·å–æ‰€æœ‰ç©ºå•å…ƒæ ¼
         * @returns {Array<{r: number, c: number}>}
         */
        function getAllEmptyCells() {
            const emptyCells = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === EMPTY) emptyCells.push({ r, c });
                }
            }
            return emptyCells;
        }

        /**
         * ä¸­ç­‰éš¾åº¦AIï¼šåŸºäºè§„åˆ™çš„èµ°æ³•ã€‚AIæ‰§PLAYER_TWO_PIECE, å¯¹æ‰‹æ‰§PLAYER_ONE_PIECE
         */
        function findBestMoveMedium() {
            // 1. AI (PLAYER_TWO_PIECE) èƒ½èµ¢å—ï¼Ÿ
            let move = findPatternMoveForPlayer(PLAYER_TWO_PIECE, 5, true, true);
            if (move) return move;

            // 2. ç©å®¶ (PLAYER_ONE_PIECE) èƒ½èµ¢å—ï¼Ÿï¼ˆé˜²å®ˆï¼‰
            move = findPatternMoveForPlayer(PLAYER_ONE_PIECE, 5, true, true);
            if (move) return move;
            
            // 3. AIèƒ½å½¢æˆæ´»å››å—?
            move = findPatternMoveForPlayer(PLAYER_TWO_PIECE, 4, true, false);
            if (move) return move;

            // 4. ç©å®¶èƒ½å½¢æˆæ´»å››å—? (é˜²å®ˆ)
            move = findPatternMoveForPlayer(PLAYER_ONE_PIECE, 4, true, false);
            if (move) return move;
            
            // 5. AIèƒ½å½¢æˆå†²å››æˆ–æ´»ä¸‰
            move = findPatternMoveForPlayer(PLAYER_TWO_PIECE, 4, false, false); // ä»»ä½•å››
            if (move) return move;
            move = findPatternMoveForPlayer(PLAYER_TWO_PIECE, 3, true, false); // æ´»ä¸‰
            if (move) return move;

            // 6. ç©å®¶èƒ½å½¢æˆå†²å››æˆ–æ´»ä¸‰å—? (é˜²å®ˆ)
            move = findPatternMoveForPlayer(PLAYER_ONE_PIECE, 4, false, false); // é˜²ä»»ä½•å››
            if (move) return move;
            move = findPatternMoveForPlayer(PLAYER_ONE_PIECE, 3, true, false); // é˜²æ´»ä¸‰
            if (move) return move;

            // 7. AIå°è¯•å½¢æˆçœ ä¸‰
            move = findPatternMoveForPlayer(PLAYER_TWO_PIECE, 3, false, false);
            if (move) return move;
            
            // 8. ç©å®¶çœ ä¸‰ (é˜²å®ˆ)
            move = findPatternMoveForPlayer(PLAYER_ONE_PIECE, 3, false, false);
            if (move) return move;

            // 9. AIå°è¯•å½¢æˆæ´»äºŒ
            move = findPatternMoveForPlayer(PLAYER_TWO_PIECE, 2, true, false);
            if (move) return move;
            
            // 10. ç©å®¶æ´»äºŒ (é˜²å®ˆ) - å¯é€‰ï¼Œè¾ƒä½ä¼˜å…ˆçº§
            move = findPatternMoveForPlayer(PLAYER_ONE_PIECE, 2, true, false);
            if (move) return move;


            // 11. å¯å‘å¼é€‰æ‹©: é è¿‘ä¸­å¿ƒæˆ–ç°æœ‰æ£‹å­
            const emptyCells = getAllEmptyCells();
            if (emptyCells.length === 0) return null;

            const centerR = Math.floor(BOARD_SIZE / 2);
            const centerC = Math.floor(BOARD_SIZE / 2);
            if (board[centerR][centerC] === EMPTY) return {r: centerR, c: centerC};

            const adjacentMoves = [];
            for (const cell of emptyCells) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = cell.r + dr;
                        const nc = cell.c + dc;
                        if (isValid(nr, nc) && board[nr][nc] !== EMPTY) {
                            adjacentMoves.push(cell);
                            break; 
                        }
                    }
                    if (adjacentMoves.includes(cell)) break; 
                }
            }
            if (adjacentMoves.length > 0) {
                return adjacentMoves[Math.floor(Math.random() * adjacentMoves.length)];
            }
            
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
        }

        /**
         * è¾…åŠ©å‡½æ•°ï¼šä¸ºæŒ‡å®šç©å®¶æ‰¾åˆ°å½¢æˆç‰¹å®šæ£‹å‹ï¼ˆNå­ï¼Œæ˜¯å¦æ´»æ£‹ï¼‰çš„è½å­ç‚¹
         */
        function findPatternMoveForPlayer(player, count, isOpenEnded, exactWin) {
            const emptyCells = getAllEmptyCells();
            for (const cell of emptyCells) {
                board[cell.r][cell.c] = player;
                if (checkPatternAt(cell.r, cell.c, player, count, isOpenEnded, exactWin)) {
                    board[cell.r][cell.c] = EMPTY;
                    return cell;
                }
                board[cell.r][cell.c] = EMPTY;
            }
            return null;
        }

        /**
         * æ£€æŸ¥åœ¨ (r,c) è½å­åï¼Œæ˜¯å¦å½¢æˆäº† player çš„ç‰¹å®šæ£‹å‹
         * (æ­¤å‡½æ•°çš„ä¸­ç­‰éš¾åº¦AIå®ç°ä¸­çš„ openEnds é€»è¾‘å¯èƒ½ä¸å®Œç¾, ä½†å¯¹æ ¸å¿ƒåŠŸèƒ½å½±å“æœ‰é™)
         */
        function checkPatternAt(r, c, player, targetCount, mustBeOpen, exactWin) {
            const directions = [[0,1], [1,0], [1,1], [1,-1]];
            for (const [dr, dc] of directions) {
                let currentLinePieces = 1;
                let openEnds = 0;
                let consecutivePiecesCoords = [{r,c}]; // ç”¨äºç²¾ç¡®æ´»æ£‹åˆ¤æ–­

                // æ­£æ–¹å‘
                for (let i = 1; i < 6; i++) { // æ£€æŸ¥è¶³å¤Ÿè¿œ
                    const nr = r + dr * i;
                    const nc = c + dc * i;
                    if (isValid(nr, nc) && board[nr][nc] === player) {
                        currentLinePieces++;
                        consecutivePiecesCoords.push({r: nr, c: nc});
                    } else if (isValid(nr, nc) && board[nr][nc] === EMPTY) {
                        // æ£€æŸ¥è¿™ä¸ªç©ºä½æ˜¯å¦ç´§é‚»æ£‹å­ä¸²
                        if (board[r + dr * (i-1)][c + dc * (i-1)] === player) openEnds++;
                        break;
                    } else { break; } // è¾¹ç•Œæˆ–å¯¹æ–¹æ£‹å­
                }
                // åæ–¹å‘
                for (let i = 1; i < 6; i++) {
                     const nr = r - dr * i;
                     const nc = c - dc * i;
                     if (isValid(nr, nc) && board[nr][nc] === player) {
                        currentLinePieces++;
                        consecutivePiecesCoords.unshift({r: nr, c: nc}); // åŠ åˆ°å¼€å¤´
                     } else if (isValid(nr, nc) && board[nr][nc] === EMPTY) {
                        if (board[r - dr * (i-1)][c - dc * (i-1)] === player) openEnds++;
                        break;
                     } else { break; }
                }
                
                if (exactWin) { // å¦‚äº”å­è¿ç 
                    if (currentLinePieces >= targetCount) return true; // >=5 å³å¯
                } else { // ä¸€èˆ¬æ¨¡å¼ï¼Œå¦‚æ´»ä¸‰ã€æ´»å››
                    if (mustBeOpen) {
                        if (currentLinePieces === targetCount) {
                            // ç²¾ç¡®åˆ¤æ–­æ´»æ£‹ï¼ˆä¸¤ç«¯å¿…é¡»æ˜¯ç©ºï¼‰
                            if (consecutivePiecesCoords.length !== targetCount) continue; // ç¡®ä¿æ˜¯çº¯ç²¹çš„ targetCount è¿å­

                            const firstPiece = consecutivePiecesCoords[0];
                            const lastPiece = consecutivePiecesCoords[targetCount - 1];
                            
                            const beforeFirstR = firstPiece.r - dr;
                            const beforeFirstC = firstPiece.c - dc;
                            const afterLastR = lastPiece.r + dr;
                            const afterLastC = lastPiece.c + dc;

                            if (isValid(beforeFirstR, beforeFirstC) && board[beforeFirstR][beforeFirstC] === EMPTY &&
                                isValid(afterLastR, afterLastC) && board[afterLastR][afterLastC] === EMPTY) {
                                return true; // æ˜¯æ´»æ£‹
                            }
                        }
                    } else { // çœ æ£‹ (å†²å››ï¼Œçœ ä¸‰ç­‰)
                        if (currentLinePieces === targetCount && openEnds >= 1) { // è‡³å°‘ä¸€ç«¯æ˜¯æ´»çš„
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /**
         * å›°éš¾éš¾åº¦AIï¼šåŸºäºè¯„åˆ†çš„å¯å‘å¼æœç´¢ã€‚AIæ‰§PLAYER_TWO_PIECE, å¯¹æ‰‹æ‰§PLAYER_ONE_PIECE
         */
        function findBestMoveHard() {
            let bestScore = -Infinity;
            let bestMoves = [];
            const emptyCells = getAllEmptyCells();

            if (emptyCells.length === 0) return null;
            if (emptyCells.length === BOARD_SIZE * BOARD_SIZE) { // å¼€å±€
                return { r: Math.floor(BOARD_SIZE / 2), c: Math.floor(BOARD_SIZE / 2) };
            }

            for (const cell of emptyCells) {
                let score = 0;
                // è¿›æ”»åˆ† (AIè½å­)
                board[cell.r][cell.c] = PLAYER_TWO_PIECE;
                score += evaluateBoardStateForPlayer(PLAYER_TWO_PIECE, board); // è¯„ä¼°æ•´ä¸ªæ£‹ç›˜
                // é˜²å®ˆåˆ† (æ¨¡æ‹Ÿç©å®¶è½å­ï¼Œç„¶åè¯„ä¼°AIé˜»æ­¢åçš„å±€é¢)
                board[cell.r][cell.c] = PLAYER_ONE_PIECE;
                // ç¨å¾®å¢åŠ é˜²å®ˆæƒé‡
                score += evaluateBoardStateForPlayer(PLAYER_ONE_PIECE, board) * 1.1; 
                board[cell.r][cell.c] = EMPTY; // æ¢å¤

                score += Math.random() * 0.1; // å¾®å°éšæœºæ€§

                if (score > bestScore) {
                    bestScore = score;
                    bestMoves = [cell];
                } else if (score === bestScore) {
                    bestMoves.push(cell);
                }
            }
            
            if (bestMoves.length === 0) return emptyCells[Math.floor(Math.random() * emptyCells.length)];
            return bestMoves[Math.floor(Math.random() * bestMoves.length)];
        }
        
        /**
         * è¯„ä¼°æ•´ä¸ªæ£‹ç›˜çŠ¶æ€å¯¹æŸä¸ªç©å®¶çš„åˆ†æ•° (å›°éš¾AIä½¿ç”¨)
         * @param {number} player - è¯„ä¼°å¯¹è±¡ç©å®¶
         * @param {Array<Array<number>>} currentBoard - å½“å‰æ£‹ç›˜çŠ¶æ€
         * @returns {number} - æ£‹ç›˜æ€»åˆ†
         */
        function evaluateBoardStateForPlayer(playerForScore, currentBoard) {
            let totalScore = 0;
            // éå†æ£‹ç›˜ä¸Šæ‰€æœ‰å¯èƒ½çš„äº”å…ƒç»„ (æ°´å¹³, å‚ç›´, åŒå¯¹è§’çº¿)
            const directions = [[0,1], [1,0], [1,1], [1,-1]];

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    for (const [dr, dc] of directions) {
                        // æ„é€ ä¸€ä¸ªä»æ­¤ç‚¹å¼€å§‹çš„äº”å…ƒç»„
                        const line = [];
                        let validLine = true;
                        for (let i = 0; i < 5; i++) {
                            const nr = r + dr * i;
                            const nc = c + dc * i;
                            if (isValid(nr, nc)) {
                                line.push(currentBoard[nr][nc]);
                            } else {
                                validLine = false;
                                break;
                            }
                        }
                        if (validLine) {
                            totalScore += scoreLinePattern(line, playerForScore);
                        }
                    }
                }
            }
            return totalScore;
        }


        /**
         * ä¸ºä¸€æ¡5æ ¼çº¿è¯„åˆ† (åŸºäºè¯¥çº¿ä¸­æŒ‡å®šç©å®¶çš„æ£‹å­æƒ…å†µ)
         */
        function scoreLinePattern(line, player) {
            let pCount = 0; let oCount = 0; let eCount = 0;
            const opponent = (player === PLAYER_ONE_PIECE) ? PLAYER_TWO_PIECE : PLAYER_ONE_PIECE;

            for (const cell of line) {
                if (cell === player) pCount++;
                else if (cell === opponent) oCount++;
                else eCount++;
            }

            if (pCount > 0 && oCount > 0) return 0; // æ··åˆçº¿ï¼Œä»·å€¼ä½
            if (oCount > 0) return 0; // è¢«å¯¹æ‰‹å æ®ï¼Œå¯¹å½“å‰playeræ— è¿›æ”»ä»·å€¼

            if (pCount === 5) return WIN_SCORE;
            if (pCount === 4 && eCount === 1) return 50000; // æ´»å››/çœ å›› (ç®€åŒ–)
            if (pCount === 3 && eCount === 2) return 5000;  // æ´»ä¸‰ (ç®€åŒ–)
            if (pCount === 2 && eCount === 3) return 500;   // æ´»äºŒ (ç®€åŒ–)
            if (pCount === 1 && eCount === 4) return 50;    // æ´»ä¸€ (ç®€åŒ–)
            return 0;
        }
        
        function findRandomMove() {
            const emptyCells = getAllEmptyCells();
            return emptyCells.length > 0 ? emptyCells[Math.floor(Math.random() * emptyCells.length)] : null;
        }

        // --- UI æ›´æ–°å‡½æ•° ---
        /**
         * æ›´æ–°æ¸¸æˆçŠ¶æ€æ˜¾ç¤º
         * @param {string} [customMessage] - è‡ªå®šä¹‰æ¶ˆæ¯ï¼Œå¯é€‰
         */
        function updateGameStatus(customMessage) {
            if (customMessage) {
                gameStatusDiv.textContent = customMessage;
                return;
            }
            if (gameOver || !gameMode) {
                 if (!gameMode) gameStatusDiv.textContent = 'è¯·é€‰æ‹©æ¸¸æˆæ¨¡å¼å¼€å§‹æ¸¸æˆ';
                return;
            }

            if (gameMode === 'ai') {
                if (currentPlayer === PLAYER_ONE_PIECE) {
                    gameStatusDiv.textContent = 'è½®åˆ°ä½ äº† (é»‘æ£‹)';
                } else { // PLAYER_TWO_PIECE (AI)
                    gameStatusDiv.textContent = 'ç”µè„‘æ­£åœ¨æ€è€ƒ... (ç™½æ£‹)';
                }
            } else if (gameMode === 'twoPlayer') {
                if (currentPlayer === PLAYER_ONE_PIECE) {
                    gameStatusDiv.textContent = 'è½®åˆ°ç©å®¶1 (é»‘æ£‹)';
                } else { // PLAYER_TWO_PIECE
                    gameStatusDiv.textContent = 'è½®åˆ°ç©å®¶2 (ç™½æ£‹)';
                }
            }
        }

        function showMessage(text) {
            messageText.textContent = text;
            messageBox.classList.remove('hidden');
        }

        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        // --- æ¸¸æˆå¯åŠ¨ ---
        drawBoard(); // å…ˆç”»ä¸€ä¸ªç©ºæ£‹ç›˜
        updateGameStatus(); // æ˜¾ç¤ºåˆå§‹æç¤º "è¯·é€‰æ‹©æ¸¸æˆæ¨¡å¼..."
        boardOverlay.style.display = 'block'; // åˆå§‹æ—¶è¦†ç›–æ£‹ç›˜ï¼Œå› ä¸ºæ²¡æœ‰é€‰æ‹©æ¨¡å¼

    </script>
</body>
</html>
